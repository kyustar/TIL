# 17장 냄새와 휴리스틱

**코드 냄새**(코드를 짜면서 사용하는 기교)와 

**휴리스틱**(불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나, 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 사람들이 빠르게 사용할 수 있게 보다 용이하게 구성된 간편추론의 방법)

> 주석

- C1 : 부적절한 정보

    다른 시스템에 저장할 정보는 주석으로 적절하지 못하다.

    - 일반적으로 작성자, 최종 수정일, SPR(Software Problem Report)번호 등과 같은 메타 정보만 주석으로 넣는다.
    - 주석은 코드와 설계에 기술적인 설명을 부연하는 수단이다.
- C2 : 쓸모 없는 주석

    오래된 주석, 엉뚱한 주석, 잘못된 주석은 쓸모가 없다.

    쓸모 없는 주석은 일단 들어가고 나면 코드에서 쉽게 멀어진다.

- C3 : 중복된 주석

    코드만으로 충분한데 구구절절 설명하는 주석이 중복된 주석이다. (코드로 말해라

- C4 : 성의없는 주석

    주석을 달 참이라면 시간을 들여 최대한 간결하고 명료하게 작성한다.

- C5 : 주석 처리된 코드

    주석으로 처리된 코드가 줄줄이 나오면 신경이 아주 거슬린다.

    - 누군가에게 필요한 코드라고 생각하여 누구도 삭제하지 않는다

    → 그래서 그 코드는 그 자리에 남아 매일매일 낡아간다.

    - 주석으로 처리된 코드는 발견 즉시 지워버려라! ( 소스 관리 시스템이 기억하니까 )

> 환경

- E1 : 한 단계로 빌드해야 한다.

    빌드는 한 단계로 끝나야 한다.

    - 소스 코드 관리 시스템에서 이것저것 따로따로 체크아웃할 필요가 없어야한다.
    - 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.
- E2 : 한 단계로 테스트해야 한다.

    모든 단위 테스트는 한 명령으로 돌려야 한다.

    - 모든 테스트를 한 번에 실행하는 방법이 빠르고, 쉽고, 명백하다.

> 함수

- F1 : 너무 많은 인수

    함수에서 인수 개수는 작을수록 좋다. 아예 없으면 가장 좋다.

- F2 : 출력 인수

    일반적으로 독자는 인수를 입력으로 간주한다.

    함수에서 뭔가를 변경해야 한다면 함수가 속한 객체의 상태를 변경해야한다. (출력 인수를 쓰지마라!)

- F3 : 플래그 인수

    boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거다.

    플래그 인수는 혼란을 초래하므로 피해야 마땅하다.

- F4 : 죽은 함수

    아무도 호출하지 않는 함수는 삭제한다.

> 일반

- G1 : 한 소스 파일에 여러 언어를 사용하는 것을 지양해라.

    오늘날 프로그래밍 환경은 한 소스 파일 내에서 다양한 언어를 지원한다. 

    ex) JSP

    - 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.
    - 현실적으로 불가피하다면, 최대한 소스파일에서 언어 수와 범위를 줄이자.
- G2 : 당연한 동작과 기능을 제공하라.

    최소 놀람의 원칙에 의거해 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야한다.

    ```java
    Day day = DayDate.StringToDay(String dayName);
    //Monday를 Day.MonDay로 변환 기대
    //요일 약어도 올바로 변환 기대
    //대소문자는 당연히 구분하지 않으리라 기대
    ```

    - 당연한 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수 이름만으로 함수 기능을 직관적으로 예상하기 어렵다.
- G3 : 경계를 올바로 처리해라.

    코드는 올바로 동작해야 한다. 그런데 우리는 올바른 동작이 아주 복잡하다는 사실을 자주 간과한다.

    - 흔히 개발자들은 직관에 의존할 뿐 모든 경계와 구석진 곳에서 코드를 증명하려 애쓰지 않는다.
    - 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성해라.

- G4 : 안전 절차를 무시하지마라.

    체르노빌 원전 사고는 책임자가 실험을 수행하기에 번거롭다는 이유로 안전 절차를 무시하는 바람에 일어났다.

    - 컴파일러의 경고를 꺼버리면 빌드가 쉬워질지 모르겠지만, 자칙하면 끝없는 디버깅에 시달린다.
    - 실패하는 테스트 케이스를 무시하는 태도는 신용카드가 공짜 돈이라는 생각만큼 위험하다.
- G5 :  중복

    중복을 발견할 때마다 추상화할 기회로 간주하라.

    → 중복 코드를 하위 루틴이나 다른 클래스로 분리하라.

    → 추상화로 중복을 정리하면 설계 언어의 어휘가 늘어난다.

    → 다른 프로그래머들이 그만큼 어휘를 사용하기 쉬워진다.

    → 추상화 수준을 높였으므로 구현이 빨라지고 오류가 적어진다

    - 똑같은 코드가 여러 차례 나오는 중복

    → 간단한 함수로 교체한다.

    - 여러 모듈에서 일련의 switch/case 나 if/else 문으로 똑같은 조건을 거듭 확인하는 중복

    → 다형성으로 대체한다.

    - 알고리즘이 유사하나 코드가 서로 다른 중복

    → TEMPLATE METHOD 패턴이나 STRATEGY 패턴으로 중복을 제거한다.

- G6 : 추상화 수준이 올바르지 못하다.

    추상화는 저차원 상세 개념에서 고차원 일반 개념을 분리한다.

    모든 저차원 개념은 파생 클래스에 넣고, 고차원 개념은 기초 클래스에 넣는다.

    - 때로는 기초 클래스와 파생 클래스로 분리하고, 때로는 소스 파일과 모듈과 컴포넌트로 분리한다.
    - 고차원 개념과 저차원 개념을 섞어서는 안 된다.
- G7 : 기초 클래스가 파생 클래스에 의존한다.

    기초 클래스와 파생 클래스로 나누는 이유?

    →고차원 기초 클래스 개념을 저차원 파생 클래스 개념으로부터 분리해 독립성을 보장한다.

    - 기초 클래스는 파생 클래스를 아예 몰라야 한다.
    - 예외 : 파생 클래스 개수가 확실히 고정되었다면 ( FSM (Finite State Machine))

    기초 클래스와 파생 클래스를 다른 JAR 파일로 배포한다면?

    - 독립적인 개별 컴포넌트 단위로 시스템을 배치할 수 있다.
    - 변경이 시스템에 미치는 영향이 적어지므로 시스템을 유지 보수하기 쉬워진다.
- G8 : 과도한 정보

    잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. 그래서 결합도가 낮다.

    - 클래스가 제공하는 메서드 수는 작을수록 좋다.
    - 함수가 아는 변수도 작을수록 좋다.
    - 정보를 제한해 결합도를 낮춰라.
- G9 : 죽은 코드

    죽은 코드란 실행되지 않는 코드를 가리킨다.

    죽은 코드를 발견하면 시스템에서 제거하라.

- G10 : 수직 분리

    변수와 함수는 사용되는 위치에 가깝게 정의해야한다.

- G11 : 일관성 부족

    어떤 개념을 특정 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현한다.

    ```java
    processVertificationRequest();
    processDeleteRequest();
    ```

    간단한 일관성만으로도 코드를 읽고 수정하기가 대단히 쉬워진다.

- G12 : 잡동사니

    잡동사니의 예

    - 비어 있는 기본 생성자
    - 사용하지 않는 변수
    - 호출하지 않는 함수
    - 정보를 제공하지 못하는 주석

    잡동사니를 없애라!

- G13 : 인위적인 결합

    서로 무관한 개념을 인위적으로 결합하지 않는다.

    - enum은 특정 클래스에 속할 이유가 없다. (enum이 클래스에 속하면 사용하는 코드가 특정 클래스도 알아야함)
    - static 함수도 특정 클래스에 속할 이유가 없다.
    - 뚜렷한 목적 없이 변수, 상수, 함수를 당장 편한 위치에 넣어버리는 것은 게으르고 부주의한 행동이다.
- G14 : 기능욕심

    클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.

- G15 : 선택자 인수?

    선택자 인수는 목적을 기억하기 어려울 뿐 아니라 각 선택자 인수가 여러 함수를 하나로 조합한다.

    → 선택자 인수는 큰 함수를 작은 함수 여럿으로 쪼개지 않으려는 게으름의 소산이다.

    ```java
    public int calculateWeeklyPay(boolean overtime){
    	...
    }
    ```

    → 독자는 calculateWeeklyPay(false)라는 코드를 발견할 때마다 의미를 떠올리느라 골치를 앓는다.

    → 부울 인수 뿐만 아니라 enum, int 등 함수 동작을 제어하려는 인수는 하나 같이 바람직하지 않다. (선택자 제어는 옳지 않다!)

    → 인수를 넘겨 동작을 선택하는 대시 새로운 함수를 만드는 편이 좋다.

- G16 : 모호한 의도

    코드를 짤 때는 의도를 최대한 분명히 밝힌다.

- G17 : 잘못 지운 책임

    코드를 배치하는 위치는 가장 중요한 결정 중 하나다.

    - 개발자에게 편한 함수 배치보다 독자에게 직관적인 위치가 좋다.
    - 때로 성능을 높이고자 위치를 변경하고자 한다면, 이런 사실을 반영해 함수 이름을 제대로 지어야 한다.
- G18 : 부적절한 static 함수

    static 함수를 정의해야겠다면 반드시 재정의 가능성은 없는지 따져봐야한다.

    ```java
    HourlyPayCalculator.calculatePay(employee, overtimeRate);
    --> 수당을 계산하는 알고리즘이 여러 개 일지도 모른다.
    ```

- G19 : 서술적 변수

    프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법이다.

    ```java
    Matcher match = headerPattern.matcher(line);
    if(match.find()){
    	String key = match.group(1);
    	String value = match.group(2);
    	headers.put(key.toLowerCase(), value);
    }
    //서술적인 변수 이름을 사용한 탓에 첫번쨰 일치 그룹이 key임이 명확히 드러난다.
    ```

    - 서술적인 변수 이름은 많이 써도 괜찮다.
- G20 : 이름과 기능이 일치하는 함수

    ```java
    Date newDate = date.add(5);
    // 5일을 더하나? 5주를 더하나? 5시간? 알수없다.
    ```

    - 일은 더한다면 addDaysTo();
    - 이름만으로 함수의 기능을 알 수 있도록 만들어라.
- G21 : 알고리즘을 이해하라
    - 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인해라.
    - 알고리즘이 올바르다는 사실을 확인하고 이해하려면 기능이 뻔히 보일 정도로 함수를 깔끔하고 명확하게 재구성하는 방법이 최고다.
- G22 : 논리적 의존성을 물리적으로 드러내라

- G23 : if/else 혹은 Switch/case문 보다는 다형성을 사용하라.
    - switch문을 사용하는 이유는 그 상황에서 가장 손쉬운 선택이기 때문이다.

    → switch를 선택하기 전에 다형성을 먼저 고려해라.

    - 유형보다 함수가 더 쉽게 변하는 경우는 드물다.

    → 모든 switch문을 의심해라.

- G24 : 표준 포기법을 따르라.

    팀은 업계 표준에 기반한 구현 표준을 따라야 한다. 그리고 팀이 정한 표준은 팀원들 모두가 따라야 한다.

- G25 : 매직 숫자는 명명된 상수로 교체하라.

    - 어떤 상수는 이해하기 쉬우므로, 코드 자체가 자명하다면, 상수 뒤로 숨길 필요 없다.

    ```java
    double milesWalked = feetWalked/5280.0;
    ```

    - 매직 숫자라는 용어는 단지 숫자만 의미하지 않는다. 의미가 분명하지 않은 토큰을 모두 가리킨다.

    ```java
    assertEquals(7777, Employee.find("John Doe").employeeNumber());
    ```

- G26 : 정확하라

    코드에서 뭔가를 결정할 때는 정확히 결정해야한다.

    -안좋은 예

    - 부동소수점으로 통화를 표현
    - 갱신 가능성이 희박하다고 잠금과 트랜잭션 관리를 건너뛰는 행동
    - List선언할 변수를 ArrayList로 선언하는 행동

    코드의 모호성와 부정확은 의견차나 게으름의 결과다.

- G27 : 관례보다 구조를 사용하라

    명명 관례도 좋지만 구조 자체로 강제하면 더 좋다.

    ex) enum변수가 switch/case문 보다 추상메서드가 있는 기초 클래스가 더 좋다

- G28 : 조건을 캡슐화하라

    부울 논리는 이해하기 어렵다. 조건의 의도를 분명히 밝히는 함수로 표현하라.

    ```java
    if(shouldBeDeleted(timer)) (O)
    if(timer.hasExpired() && !timer.isRecurrent()) (X)
    ```

- G29 : 부정 조건은 피하라.

    부정 조건은 긍정 조건보다 이해하기 어렵다.

    ```java
    if(buffer.shouldCompact()) (O)
    if(!buffer.shouldNoeCompact()) (X)
    ```

- G30 : 함수는 한 가지만 해야 한다.

    함수는 한 가지만 수행하는 좀 더 작은 함수 여럿으로 나눠야 마땅하다.

    ```java
    public void(pay()){
    	for(Employee e : employees){ --> 탐색
    		if(e.isPayday()){ --> 월급일 확인
    				Money pay = e.calculatePay(); --> 계산 및 지급
    				e.deliverPay(pay);
    		}
    	}
    }
    ```

- G31 : 숨겨진 시간적인 결합

    때로는 시간적인 결합이 필요하다. 함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다.

    ```java
    Gradient gradient = saturateGradient();
    List<Spline> splines = reticulateSplines(gradient);
    diveForMoog(splines, reason);
    ```

- G32 : 일관성을 유지하라

    코드 구조를 잡을 때는 이유를 고민해라.

    시스템 전반에 걸쳐 구조가 일관성이 있다면 남들도 일관성을 따르고 보존한다.

    ```java
    public class AliasLinkWiget extends ParentWidget{
    	public static class VariableExpandingWidgetRoot{
    		...
    	}
    }
    ```

    - 다른 클래스의 유틸리티가 아닌 public 클래스는 자신이 아닌 클래스 범위 안에서 선언하면 안된다.
    - 패키지 최상위 수준에 public 클래스로 선언하는 관례가 일반적이다.
- G33 : 경계 조건을 캡술화하라

    경계 조건은 빼먹거나 놓치기 십상이다. 경계 조건은 한 곳에서 별도로 처리한다.

    ```java
    if(level + 1 < tags.length){
    	parts = new Parse(body, tags, level + 1, offset + endTag)'
    	body = null;
    }
    --> int nextLevel = level + 1; ( 경계 조건 변수로 캡슐화 )
    ```

- G34 : 함수는 추상화 수준을 한 단계만 내려가야 한다.

    함수 내 모든 문장은 추상화 수준이 동일해야 한다. 그리고 추상화 수준은 함수 이름이 의미하는 작업보다 한 단계만 낮아야 한다.

    ```java
    public String render() throws Exception{
    	StringBuffer html = new StringBuffer("<hr";
    	if(size > 0){
    		html.append("size = \"").append(size+1).append("\"");
    	}		
    	html.append(">");
    	return html.toString();
    }
    ```

    2개의 추상화 수준 

    (1). 수평선에 크기가 있다는 개념

    (2). HR태그 자체의 문법

    —> size 계산과 hr태그 문법이 섞여 있음.

    ```java
    public String render() throws Exception{
    	HtmlTag hr = new HtmlTag("hr");
    	if(extraDashes > 0){
    		hr.addAttribute("size", hrSize(extraDashes));
    		return hr.html();
    }

    private String hrSize(int height){
    	int hrSize = height + 1;
    	return String.format("%d", hrSize);
    }
    ```

    render → hrSize → addAttribute

- G35 : 설정 정보는 최상위에 단계에 둬라

    추상화 최상위 단계에 둬야 할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안된다.

    단, 고차원 함수에서 저차원 함수를 호출할 때 인수를 넘긴다.

- G36 : 추이적 탐색을 피하라

    일반적으로 한 모듈은 주변 모듈을 모를수록 좋다.

    A → B , B → C 다면 A → C (X)

    - 디미터의 법칙 (자신이 직접 사용하는 모듈만 알아야 한다.)

> 자바

- J1 : 긴 import 목록을 피하고 와일드카드를 사용해라.

    패키지에서 클래스 둘 이상 사용한다면 와일드카드를 사용해 패키지 전체를 가져오라.

    - 명시적인 import문은 강한 의존성을 생성하지만 와일드카드는 그렇지 않다.
    - import문은 패키지를 단순히 검색 경로에 추가하므로 진정한 의존성이 생기지 않는다.
    - 명시적으로 import문을 길게 나열해야하는 경우나 이름이 같으나 패키지가 다른 클래스는 자주 발생하지 않으므로 와일드카드 import를 사용하는 것이 좋다.
- J2 : 상수는 상속하지 않는다.

    어떤 프로그래머는 상수를 인터페이스로 넣은 다음 그 인터페이스를 상속해 해당 상수를 사용한다.

    —> 상수를 계층 맨 위에 숨겨 놨다.

    —> 대신 static import를 써라!

- J3 : 상수 대 enum

    enum은 메서드와 필드도 사용할 수 있다.

    int보다 enum이 훨씬 더 유연하고 서술적인 강력한 도구다.

> 이름

- N1 : 서술적인 이름을 사용하라.

    서술적인 이름을 신중하게 골라라.

    - 소프트웨어 가독성의 90%는 이름이 결정한다.
    - 신중하게 선택한 이름은 추가 설명을 포함한 코드보다 강력하다.
- N2 : 적절한 추상화 수준에서 이름을 선택하라

    구현을 드러내는 이름을 피하라.

    작업 대상 클래스나 함수가 위치하는 추상화 수준을 반영하는 이름을 선택하라.

    ```java
    public interface Modem{
    	boolean dial(String PhoneNumber);
    	boolean disconnect();
    	boolean send(char c);
    	char recv();
    	String getConnectedPhoneNumber();
    }
    ```

    전화선에 연결되지 않는 일부 모뎀을 사용하는 애플리케이션은??

    ```java
    public interface Modem{
    	boolean connect(String connectLocator);
    	boolean disconnect();
    	boolean send(char c);
    	char recv();
    	String getConnectedLocator();
    }
    ```

    연결 대상의 이름을 더 이상 전화번호로 제한하지 않는다.

- N3 : 가능하다면 표준 명명법을 사용하라.

    기존 명명법을 사용하는 이름은 이해하기 더 쉽다.

    - 흔히 팀마다 특정 프로젝트에 적용할 표준을 나름대로 고안한다.
    - 프로젝트에 유효한 의미가 담긴 이름을 많이 사용할수록 독자가 코드를 이해하기 쉬워진다.
- N4 : 명확한 이름

    함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.

    길어도 상관없다. 길다는 단점을 서술성이 충분히 메꾼다.

- N5 : 긴 범위는 긴 이름을 사용하라.

    이름 길이는 범위 길이에 비례해야 한다.

    - 범위가 5줄 안팎이라면 i,j와 같은 변수 이름도 괜찮다.
    - 이름이 짧은 변수나 함수는 범위가 길어지면 의미를 잃는다.
    - 이름범위가 길수록 이름을 정확하고 길게 짓는다.
- N6 : 인코딩을 피해라

    이름에 유형 정보나 범위 정보를 넣어서는 안된다. (접두어도 불필요하다)

- N7 : 이름으로 부수 효과를 설명하라

    이름에 부수 효과를 숨기지 않는다. 실제로 여러 작업을 수행하는 함수에다 동사 하나만 달랑 사용하면 곤란하다.

    ```java
    public ObjectOutputStream getOos() throw IOException{
    	if(m_oos == null){
    		m_oos = new ObjectOutputStream(m_socket.getOutputStream());
    	}
    	return m_oos;
    }
    // 생성과 반환 둘 다 있기 때문에 createOrReturnOos라는 이름이 더 좋다.
    ```

> 테스트

- T1 : 불충분한 테스트

    테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.

    테스트 케이스가 확인하지 않는 조건이나 검증하지 않는 계산이 있다면 그 테스트는 불완전하다.

- T2 : 커버리지 도구를 사용하라!

    커버리지 도구를 사용하면 테스트가 불충분한 모듈, 클래스, 함수를 찾기가 쉬워진다.

    코드 커버리지란?

    → 테스트 케이스가 얼마나 충족되었는지를 나타내는 지표

- T3 : 사소한 테스트를 건너뛰지 마라.

    사소한 테스트가 제공하는 문서적 가치는 구현에 드는 비용을 넘어간다. 그러니 사소한 테스트도 짜라.

- T4 : 무시한 테스트는 모호함을 뜻한다.

    불분명한 요구사항은 테스트 케이스를 주석으로 처리하거나 테스트 케이스에 @Ignore를 붙여 표현한다.

    —> 잘못된 테스트

- T5 : 경계 조건을 테스트하라

    경계 조건은 각별히 신경 써서 테스트하라.

- T6 : 버그 주변은 철저히 테스트하라.

    버그는 서로 모이는 경향이 있다. 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트해라.

- T7 : 실패 패턴을 살펴라

    때로는 테스트 케이스가 실패하는 패턴을 보고 문제를 진단할 수 있다.

    합리적인 순서로 정렬된 꼼꼼한 테스트 케이스는 실패 패턴을 드러낸다.

- T8 : 테스트 커버리지 패턴을 살펴라

    테스트 커버리지의 실패요소를 보고 실패원인을 찾을 수 있다.

- T9 : 테스트는 빨라야한다.

    일정이 촉박하면 느린 테스트 케이스를 제일 먼저 건너 뛴다. 그러므로 빨리 돌아가게 노력해라. 

## 결론

전문가 정신과 장인 정신은 가치에서 나온다. 그 가치에 기반한 규율과 절제가 필요하다.